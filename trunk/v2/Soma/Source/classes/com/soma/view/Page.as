package com.soma.view {	import com.soma.Soma;	import com.soma.assets.NodeParser;	import com.soma.errors.CairngormError;	import com.soma.errors.CairngormMessage;	import com.soma.events.PageEvent;	import com.soma.events.ParserEvent;	import com.soma.interfaces.IPage;	import com.soma.loader.SomaLoader;	import com.soundstep.ui.BaseUI;	import flash.display.DisplayObject;	import flash.display.DisplayObjectContainer;	import flash.display.MovieClip;	import flash.events.Event;	import flash.system.LoaderContext;	import flash.utils.Dictionary;	/**     * <p><b>Author:</b> Romuald Quantin - <a href="http://www.soundstep.com/" target="_blank">www.soundstep.com</a><br/>     * <p><b>Information:</b><br/>     * Blog page - <a href="http://www.soundstep.com/blog/downloads/somaui/" target="_blank">SomaUI</a><br/>     * How does it work - <a href="http://www.soundstep.com/somaprotest/" target="_blank">Soma Protest</a><br/>     * Project Host - <a href="http://code.google.com/p/somamvc/" target="_blank">Google Code</a><br/>     * Documentation - <a href="http://www.soundstep.com/blog/source/somaui/docs/" target="_blank">Soma ASDOC</a><br/>     * <b>Class version:</b> 2.0<br/>     * <b>Actionscript version:</b> 3.0</p>     * <p><b>Copyright:</b></p>     * <p>The contents of this file are subject to the Mozilla Public License<br />     * Version 1.1 (the "License"); you may not use this file except in compliance<br />     * with the License. You may obtain a copy of the License at<br /></p>     *      * <p><a href="http://www.mozilla.org/MPL/" target="_blank">http://www.mozilla.org/MPL/</a><br /></p>     *      * <p>Software distributed under the License is distributed on an "AS IS" basis,<br />     * WITHOUT WARRANTY OF ANY KIND, either express or implied.<br />     * See the License for the specific language governing rights and<br />     * limitations under the License.<br /></p>     *      * <p>The Original Code is Soma.<br />     * The Initial Developer of the Original Code is Romuald Quantin.<br />     * Initial Developer are Copyright (C) 2008-2009 Soundstep. All Rights Reserved.</p>     *      * <p><b>Usage:</b><br/>     * The Page view class must be extended to create your own page.<br/><br/>     * <b>Create a new page</b><br/><br/>     * 1. Create a page node in the XML Site Definition.     * <listing version="3.0">&lt;page id="mypage_id" type="MyPage" urlfriendly="my-page"&gt;    &lt;title&gt;&lt;![CDATA[My Page]]&gt;&lt;/title&gt;&lt;/page&gt;     * </listing>     * 2. Create a class that is extending com.soma.view.Page and implementing com.soma.interfaces.IPage.     * <listing version="3.0">package com.project.pages {        import com.soma.interfaces.IPage;    import com.soma.view.Page;    import com.soma.events.PageEvent;        public class MyPage extends Page implements IPage {            public function MyPage() {            addEventListener(PageEvent.INITIALIZED, initialized, false, 0, true);        }            private function initialized(e:PageEvent = null):void {            removeEventListener(PageEvent.INITIALIZED, initialized, false);            // initialization complete, build page elements.        }            override public function transitionIn():void {            // show my page and call: super.transitionIn            Tweener.addTween(this, {time:1, _autoAlpha:1, onComplete:super.transitionIn});        }            override public function transitionInComplete():void {            // end of the transition to show the page            super.transitionInComplete();        }            override public function transitionOut():void {            // hide my page and call: super.transitionOut            Tweener.addTween(this, {time:1, _autoAlpha:0, onComplete:super.transitionOut});        }            override public function transitionOutComplete():void {            // end of the transition to hide the page, the page is about to be removed            // use a dispose function to destroy elements and listeners, then call super.transitionOutComplete            dispose();            super.transitionOutComplete();        }    }}     * </listing>     * 3. Register the page class (in the config file seems to be the best place, or anywhere before Soma starts).     * <listing version="3.0">Soma.getInstance().registerClass(MyPage);     * </listing>     *      * <b>Variables</b><br/><br/>     * The page super class will initialize some variables before dispatching a PageEvent.INITIALIZED event, you can access them straight from your own page as you're going to extend this Page.     * <ul>     * 	<li>id: id of the page</li>     * 	<li>pageXML: page node (XML) of this page</li>     * 	<li>baseUI: a BaseUI instance for layout purpose</li>     * 	<li>content: content node (XML) of the page, it is use by the NodeParser instance.</li>     * 	<li>type: type of the page (type attribute in the page node)</li>     * 	<li>depth: depth of the page (depth attribute in the page node)</li>     * 	<li>parser: NodeParser instance that will be used to create and load the assets found in the content node</li>     * 	<li>parserTarget: the target where the assets will be added to the display list (the page itself is the default but you can specify another container)</li>     * 	<li>assets: array containing the assets created by the NodeParser instance</li>     * </ul>     *      * <b>Assets</b><br/><br/>     * A NodeParser instance is created by the page and it will look for a content node in your page node. The parser will try to instantiate and/or load any children of this content node (unless you add an attribute "parse" set to false).<br/><br/>     * If asset nodes have been found, the NodeParser will parse and instantiates them. The page will then dispatch a PageEvent.CONTENT_PARSED event. If you don't have any "external assets" (such as a picture or anything that requires loading), the assets are ready to use.<br/><br/>     * If the node parser has found external assets, it will load them. Your assets won't be ready when you will receive the PageEvent.CONTENT_PARSED event. When the parser will be completely finished (instantiating and loading), the page event will dispatched a PageEvent.CONTENT_COMPLETE.<br/><br/>     * To receive the information, add the following listeners:     * <listing version="3.0">addEventListener(addEventListener(PageEvent.CONTENT_PARSED, contentParsedHandler);addEventListener(addEventListener(PageEvent.CONTENT_COMPLETE, contentCompleteHandler);     * </listing>     *      * <b>Show and Hide a page</b><br/><br/>     * As the PageManager can't know how you are going to show and hide your pages (and how long time it will take), it will give you the time to do that in 4 methods that must be overridden.     * <ul>     *  <li>showing process: transitionIn (start) and transitionInComplete (end)</li>     *  <li>hiding process: transitionOut (start) and transitionOutComplete (end)</li>     * </ul>     * You can show your page and/or your page elements in the overridden transitionIn method and call super.transitionIn when you are done.     * <listing version="3.0">override public function transitionIn():void {    // show my page and call: super.transitionIn    Tweener.addTween(this, {time:1, _autoAlpha:1, onComplete:super.transitionIn});}override public function transitionInComplete():void {    // end of the transition to show the page    super.transitionInComplete();}     * </listing>     * You can hide your page and/or your page elements in the overridden transitionOut method and call super.transitionOut when you are done. Call the super methods are important as it will make the PageManager continue its process.      * <listing version="3.0">override public function transitionOut():void {    // hide my page and call: super.transitionOut    Tweener.addTween(this, {time:1, _autoAlpha:0, onComplete:super.transitionOut});}override public function transitionOutComplete():void {    // end of the transition to hide the page, the page is about to be removed    // use a dispose function to destroy elements and listeners, then call super.transitionOutComplete    dispose();    super.transitionOutComplete();}     * </listing>     * <b>Control</b><br/><br/>     * You can very easily control or alter a page flow with Soma, you can listen to the PageEvent.STARTED (in the Main class for example) that is dispatched by the PageManager before doing anything.     * <listing version="3.0">Soma.getInstance().addEventListener(PageEvent.STARTED, pageHandler);private function pageHandler(event:PageEvent):void {    // every time the PageManager is about to show (and remove) a page this handler will be called.    var currentPage:Page = Soma.getInstance().page.currentPage;    var nextPageID:String = event.id;    // here I stop the PageManager to change the page:    if (nextPageID == "PageIDIdontWantToSee") event.preventDefault();}     * </listing>     *      * @see com.soma.Soma Soma     * @see com.soma.events.PageEvent PageEvent     * @see com.soma.model.PageManager PageManager     * @see com.soma.assets.ClassImport ClassImport     */	 	public class Page extends MovieClip implements IPage {		//------------------------------------		// private, protected properties		//------------------------------------				private var _id:String;		private var _pageXML:XML;		private var _baseUI:BaseUI;		private var _content:XML;		private var _type:String;		private var _depth:int;				private var _parser:NodeParser;		private var _parserTarget:DisplayObjectContainer;		private var _assets:Array;		private var _assetsDictionary:Dictionary;		private var _loader:SomaLoader;		private var _loaderContext:LoaderContext;		private var _hasExternalContent:Boolean;				private var _willBeRemoved:Boolean;				//------------------------------------		// public properties		//------------------------------------								//------------------------------------		// constructor		//------------------------------------				/** Creates a Page instance (this class should always be extended). */		public function Page() {			_willBeRemoved = false;			addEventListener(Event.ADDED_TO_STAGE, added, false, 0, true);		}				//		// PRIVATE, PROTECTED		//________________________________________________________________________________________________				private function added(e:Event = null):void {			removeEventListener(Event.ADDED_TO_STAGE, initialize, false);			_parserTarget = this;			initialize();		}				/** @private */		protected function initialize():void {			if (willBeRemoved) return;			// initalize vars			_hasExternalContent = false;			_assetsDictionary = new Dictionary(true);			_baseUI = new BaseUI(this);			_baseUI.reference = Soma.getInstance().referenceBaseUI;			if (Soma.getInstance().initialized) {				if (_id == null) throw new CairngormError(CairngormMessage.PAGE_ID_NOT_FOUND);				_pageXML = Soma.getInstance().content.getPage(_id);				_content = Soma.getInstance().content.getPageContent(_id);			}			createParser();			dispatchEvent(new PageEvent(PageEvent.INITIALIZED, _id));			startParsing();		}				/** @private */		protected function createParser():void {			if (_parser == null) {				_parser = new NodeParser(Soma.getInstance().library);			}		}		/** @private */		protected function startParsing():void {			// parser content			if (_content != null) {				if (_content.hasOwnProperty("@parse") && String(_content.@parse) == "false") return;				var externalAssets:XMLList = _content..*.(hasOwnProperty("@file"));				if (externalAssets.length() > 0) {					_loader = Soma.getInstance().loader;					_hasExternalContent = true;				}				_parser.addEventListener(ParserEvent.COMPLETE, assetsQueueComplete, false, 0, true);				_assets = parseContent(_content.children());				if (_assets != null && _assets.length) {					for (var i:int=0; i<_assets.length; i++)  {						if (_assets[i].hasOwnProperty('name')) _assetsDictionary[_assets[i].name] = _assets[i];					}					dispatchEvent(new PageEvent(PageEvent.CONTENT_PARSED, _id));				}			}		}				/** @private */		protected function parseContent(list:XMLList):Array {			_parser.add(list);			return _parser.run(_parserTarget, _baseUI, _loader);		}		/** @private */		protected function assetsQueueComplete(e:ParserEvent):void {			dispatchEvent(new PageEvent(PageEvent.CONTENT_COMPLETE, _id));		}				/** @private */		protected function disposePage():void {			removeEventListener(Event.ADDED_TO_STAGE, added, false);			if (_parser != null) {				_parser.removeEventListener(ParserEvent.COMPLETE, assetsQueueComplete, false);				_parser.dispose();				_parser = null;			}			if (_baseUI != null) {				_baseUI.dispose();				_baseUI = null;			}			while (numChildren > 0) {				removeChildAt(0);			}			disposeAssets();		}				/** @private */		protected function disposeAssets():void {			if (_assets != null && _assets.length > 0) {				for (var i:int=0; i<_assets.length; i++) {
					if (_assets[i] is DisplayObjectContainer) {						while (_assets[i].numChildren > 0) {							_assets[i].removeChildAt(0);						}					}					if (_assets[i].hasOwnProperty("dispose")) {						_assets[i].dispose();						_assets[i] = null;					}				}			}			if (_assetsDictionary != null) _assetsDictionary = null;		}		// PUBLIC		//________________________________________________________________________________________________				/**		 * Method that should be overridden, beginning of the showing process. Show your page elements here and call super.transitionIn when the page is displayed.     	 * <listing version="3.0">override public function transitionIn():void {    // show my page and/or my page elements, and call: super.transitionIn    Tweener.addTween(this, {time:1, _autoAlpha:1, onComplete:super.transitionIn});}	     * </listing>		 */		public function transitionIn():void {			transitionInComplete();		}				/**		 * Method that should be overridden, end of the showing process. You must call super.transitionInComplete.	     * <listing version="3.0">override public function transitionInComplete():void {    // end of the transition to show the page, at this moment the page is fully displayed    myMethodAferShowingThePage();    super.transitionInComplete();}     	 * </listing>		 */		public function transitionInComplete():void {			new PageEvent(PageEvent.TRANSITION_IN_COMPLETE, id).dispatch();		}				/**		 * Method that should be overridden, beginning of the hiding process. Hide your page elements here and call super.transitionOut when the page is hidden.	     * <listing version="3.0">override public function transitionOut():void {    // hide my page and/or my page elements, and call: super.transitionOut    Tweener.addTween(this, {time:1, _autoAlpha:0, onComplete:super.transitionOut});}	     * </listing>		 */		public function transitionOut():void {			transitionOutComplete();		}				/**		 * Method that should be overridden, end of the hiding process. You must call super.transitionInComplete (to allow the PageManager to remove the page and continue its process if you are using pages with depths).	     * <listing version="3.0">override public function transitionOutComplete():void {    // end of the transition to hide the page, the page is about to be removed    // use a dispose function to destroy elements and listeners, then call super.transitionOutComplete    dispose();    super.transitionOutComplete();}	     * </listing>		 */		public function transitionOutComplete():void {			removeEventListener(Event.ADDED_TO_STAGE, initialize, false);			disposePage();			if (parent is PageExternal) PageExternal(parent).transitionOutComplete();			else new PageEvent(PageEvent.TRANSITION_OUT_COMPLETE, id).dispatch();		}				/** id of page (attribute id of the page node). */		public function get id():String {			return _id;		}				public function set id(id:String):void {			_id = id;		}		     	/** page node (XML) of this page. */		public function get pageXML():XML {			return _pageXML;		}				public function set pageXML(pageXML:XML):void {			_pageXML = pageXML;		}		     	/** BaseUI instance for layout purpose. */		public function get baseUI():BaseUI {			return _baseUI;		}				public function set baseUI(baseUI:BaseUI):void {			_baseUI = baseUI;		}		     	/** content node (XML) of the page, it is use by the NodeParser instance. */		public function get content():XML {			return _content;		}				public function set content(content:XML):void {			_content = content;		}		     	/** type of the page (type attribute in the page node). */		public function get type():String {			return _type;		}				public function set type(type:String):void {			_type = type;		}		     	/** depth of the page (depth attribute in the page node). */		public function get depth():int {			return _depth;		}				public function set depth(depth:int):void {			_depth = depth;		}		 		/** NodeParser instance that will be used to create and load the assets found in the content node. */		public function get parser():NodeParser {			return _parser;		}				public function set parser(parser:*):void {			_parser = parser;		}				/** Get an array containing the assets created by the NodeParser instance (all assets that are DisplayObject subclasses, you wont find XML in this array)		 * @return An Array of assets.		 */		public function get assets():Array {			return _assets;		}				/**		 * Get an asset created and/or loaded by the NodeParser instance using the id attribute of its XML node.		 * @param id Attribute id of the XML asset node.		 * @return A DisplayObject.		 */		public function getAssetByID(id:String):DisplayObject {			return _assetsDictionary[id];		}				/** SomaLoader instance used by the NodeParser instance to load external assets. Set by default to the global loader (Soma.getInstance().loader). */		public function get loader():SomaLoader {			return _loader;		}				public function set loader(loader:SomaLoader):void {			_loader = loader;		}				/** LoaderContext instance of the SomaLoader instance of the page (null by default). */		public function get loaderContext():LoaderContext {			return _loaderContext;		}				public function set loaderContext(loaderContext:LoaderContext):void {			_loaderContext = loaderContext;		}				/**		 * Whether or external assets have been found (pictures for example, assets that have to be loaded).		 * @return A Boolean.		 */		public function get hasExternalContent():Boolean {			return _hasExternalContent;		}				/**		 * Get a String describing the page.		 * @return A String.		 */		public function info():String {			var str:String = "[Page]\n";			str += "--- id: " + id + "\n";			str += "--- type: " + type + "\n";			str += "--- depth: " + depth + "\n";			if (pageXML != null) str += "--- node: " + pageXML.toXMLString() + "\n";			return str;		}				/** Whether or not the page is about to be removed by the PageManager. */		public function get willBeRemoved():Boolean {			return _willBeRemoved;		}				public function set willBeRemoved(value:Boolean):void {			_willBeRemoved = value;		}				/** the target where the assets will be added to the display list (the page itself is the default but you can specify another container). */		public function get parserTarget():DisplayObjectContainer {			return _parserTarget;		}				public function set parserTarget(target:DisplayObjectContainer):void {			_parserTarget = target;		}	}}